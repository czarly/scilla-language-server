/*
 * generated by Xtext 2.16.0
 */
package org.butterflylabs.zilliqa.xtext.scoping

import java.util.List
import org.butterflylabs.zilliqa.xtext.scilla.Contract
import org.butterflylabs.zilliqa.xtext.scilla.Function
import org.butterflylabs.zilliqa.xtext.scilla.Library
import org.butterflylabs.zilliqa.xtext.scilla.LocalBinding
import org.butterflylabs.zilliqa.xtext.scilla.MatchExpressionSelector
import org.butterflylabs.zilliqa.xtext.scilla.MatchStatementSelector
import org.butterflylabs.zilliqa.xtext.scilla.Scilla
import org.butterflylabs.zilliqa.xtext.scilla.ScillaPackage
import org.butterflylabs.zilliqa.xtext.scilla.Transition
import org.butterflylabs.zilliqa.xtext.scilla.TransitionBody
import org.butterflylabs.zilliqa.xtext.scilla.VariableDeclaration
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class ScillaScopeProvider extends AbstractScillaScopeProvider {
	override getScope(EObject context, EReference reference) {
   		   		
   		//if (reference.EType.instanceClassName.equals("org.xtext.zilliqa.scilla.VariableDeclaration")) {
		if (reference == ScillaPackage.eINSTANCE.symbolRef_Symbol) {
		
			// get the local elements for the scope        	
        	val symbolRefScope = scopeForSymbolRef(context, reference)
        	
        	val rootElement = EcoreUtil2.getRootContainer(context)
			
        	val libraries = EcoreUtil2.getAllContentsOfType(rootElement, Library)
        	if (libraries.size() > 0) {
	        	val defaultScope = super.getScope(libraries.get(0), reference);
	        	return symbolRefScope
        	}
        	
        	return symbolRefScope
		}
   		
   		return super.getScope(context, reference);
	}
	
	def protected IScope scopeForSymbolRef(EObject context, EReference reference) { 
		val container = context.eContainer()
		
		return switch (container) {

			Scilla: 
				// recursion ends with the call to the default scope resolution for the 
				// root element to trigger the inclusion of imported namespaces
				if (container.library !== null){
					Scopes.scopeFor(container.library.functions, super.getScope(container, reference))	
				} else {
					super.getScope(container, reference)
				}
			
			Library:
				Scopes.scopeFor(container.functions.takeWhile[it != context].
					filter(VariableDeclaration), scopeForSymbolRef(container, reference) // outer scope
				)
								
			Function: 
				Scopes.scopeFor(#[container.variable], scopeForSymbolRef(container, reference))
			
			LocalBinding: 
				Scopes.scopeFor(#[container.variable], scopeForSymbolRef(container, reference))
			
			/*TypeFunction: 
				Scopes.scopeFor(#[container.variable])*/
			
			MatchStatementSelector:
				scopeForMatchStatementPatternSelector(context, reference)

			MatchExpressionSelector:
				Scopes.scopeFor(scopeForMatchExpressionPatternSelector(container), 
					scopeForSymbolRef(container, reference)
				)
				
			TransitionBody:
				Scopes.scopeFor( container.statements.takeWhile[it != context].
					filter(VariableDeclaration), scopeForSymbolRef(container, reference) // outer scope
				)
			
			Transition:
				Scopes.scopeFor(container.params, scopeForSymbolRef(container, reference))
			
			Contract:
				Scopes.scopeFor(container.fields, scopeForSymbolRef(container, reference))
			
			default: scopeForSymbolRef(container, reference)
		} 
	}
	
	// add the matched variables from the patterns to the scope for the expressions or statements within the match
	def protected IScope scopeForMatchStatementPatternSelector(EObject context, EReference reference){
		val container = context.eContainer as MatchStatementSelector
		val bindings = EcoreUtil2.getAllContentsOfType(container.pattern, VariableDeclaration)
		
		if( bindings.size > 0){
			val bindingScope = Scopes.scopeFor(bindings, 
				Scopes.scopeFor( EcoreUtil2.getAllContentsOfType(container.pattern, VariableDeclaration), scopeForSymbolRef(container, reference))
			)	
		}
		
		val bindingScope = Scopes.scopeFor(bindings, 
			Scopes.scopeFor( EcoreUtil2.getAllContentsOfType(container.pattern, VariableDeclaration), scopeForSymbolRef(container, reference))
		)
		val result = Scopes.scopeFor( container.statements.takeWhile[it != context].
			filter(VariableDeclaration), 
 			bindingScope
		)
		
		return result
	}
	
	// add the matched variables from the patterns to the scope for the expressions or statements within the match
	def protected List<VariableDeclaration> scopeForMatchExpressionPatternSelector(MatchExpressionSelector container){
		return EcoreUtil2.getAllContentsOfType(container.pattern, VariableDeclaration)
	}
}
