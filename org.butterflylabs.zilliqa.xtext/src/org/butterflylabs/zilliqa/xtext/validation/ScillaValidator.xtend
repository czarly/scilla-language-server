/*
 * generated by Xtext 2.16.0
 */
package org.butterflylabs.zilliqa.xtext.validation

import org.butterflylabs.zilliqa.xtext.scilla.Contract
import org.butterflylabs.zilliqa.xtext.scilla.GeneralAssignment
import org.butterflylabs.zilliqa.xtext.scilla.Import
import org.butterflylabs.zilliqa.xtext.scilla.MessageExpression
import org.butterflylabs.zilliqa.xtext.scilla.Scilla
import org.butterflylabs.zilliqa.xtext.scilla.ScillaPackage
import org.butterflylabs.zilliqa.xtext.scilla.SymbolRef
import org.butterflylabs.zilliqa.xtext.scilla.Transition
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.validation.Check

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class ScillaValidator extends AbstractScillaValidator {
	
	def boolean inTransition(EObject element){
			val rootElement = EcoreUtil2.getRootContainer(element) as Scilla
        	val transitions = EcoreUtil2.getAllContentsOfType(rootElement.contract.body, Transition)
        	
        	var inTransition = false
        	
        	for (Transition trans : transitions) {
  				inTransition = inTransition || EcoreUtil2.isAncestor(trans, element) 
			}
        
        	return inTransition
	}
	
	def void checkForTransitionField(SymbolRef reference, String fieldname){
		if(reference.getSymbol().getName().equals(fieldname)){
        	if(!inTransition(reference)){
	        	warning("The " + fieldname + " parameter is only available in transitions", ScillaPackage.Literals.SYMBOL_REF__SYMBOL)	
	        }
        }
	}
	
	@Check
    def void checkFieldOnlyInTransitions(SymbolRef reference) {
    	checkForTransitionField(reference, "_sender")
    	checkForTransitionField(reference, "_amount")
    	checkForTransitionField(reference, "_eventname")
    	checkForTransitionField(reference, "_accepted")
    	checkForTransitionField(reference, "_tag")
    	checkForTransitionField(reference, "_recipient")    
    }
        
    @Check
    def void checkForDeclaredOwner(Contract contract) {
    	val hasOwner = contract.fields.filter[field | field.name == "owner"].size() > 0
    	    	
        if(!hasOwner){
        	error("The contract needs to declare a owner field", ScillaPackage.Literals.CONTRACT__NAME)
        }
    }
    
    @Check
    def void checkForLibraryImport(Import imp) {
    	val String[] allowed = #["BoolUtils", "NatUtils", "ListUtils", "IntUtils", "PairUtils"]
    	    	
    	if (allowed.indexOf(imp.importedNamespace) == -1) {   	    	    	
        	error("import is restricted to standard libraries", ScillaPackage.Literals.IMPORT__IMPORTED_NAMESPACE)
        }
    }
    
    
    // TODO: This doesn't really work because Messages and Events have the same format 
    // backtracking from a send statement to the message Object can not work send statements only accept lists of messages
    // events are different because they can be backtracked to their VariableDeclaration and validated for starting with "_eventname"
    def void checkForMessageFields(MessageExpression message){
    	checkForMessageField(message, "_tag")
    	checkForMessageField(message, "_recipient")
    	checkForMessageField(message, "_amount")
    }
    
    def void checkForMessageField(MessageExpression message, String key){
    	val tag_count = message.assignments.filter[field | (field instanceof GeneralAssignment) && (field as GeneralAssignment).name == key].size()
    	
    	if (tag_count == 0){
    		error("a message needs to define " + key, ScillaPackage.Literals.MESSAGE_EXPRESSION__ASSIGNMENTS)
    	} else if(tag_count > 1){
    		error("exactly 1 " + key + " field is allowed", ScillaPackage.Literals.MESSAGE_EXPRESSION__ASSIGNMENTS)
    	}
    }
	
	@Check
	def checkDuplicateMessageFields(GeneralAssignment field) {
    	val message = (field.eContainer as MessageExpression)
    	val names = newHashSet
    	for (g : message.assignments) {
    		
        	if (g instanceof GeneralAssignment && !names.add((g as GeneralAssignment).name) && field.name == (g as GeneralAssignment).name) {
        	    error("duplicate key " + field.name, ScillaPackage.Literals.GENERAL_ASSIGNMENT__NAME)
        	}
    	}
	}	
	
}
